# Copyright (c) 2016 The Foundry Visionmongers Ltd.  All Rights Reserved.

import os.path

import nuke_internal as nuke
import nukescripts

import re
from PySide2 import QtWidgets, QtGui, QtCore

kCommandField = 'Command:'
last_cmd = ''


def script_command(default_cmd):
    global last_cmd
    p = nuke.Panel("Nuke")
    if (default_cmd != None and len(default_cmd) != 0):
        use_cmd = default_cmd
    else:
        use_cmd = last_cmd
    p.addScriptCommand(kCommandField, use_cmd)
    p.addButton("Cancel")
    p.addButton("OK")
    result = p.show()
    if result == 1:
      last_cmd = p.value(kCommandField)
      p.execute(kCommandField)



def findMaxVersionForFileName(filename):
  """Helper function for finding the max version of a paticular
  script in it's current directory.
  Note that a file in the current directory will count towards the
  current version set if the string before the v number for that file
  is the same as the string before the v numebr of the current version."""

  # Get the maximum version number based in the current files on disk
  (basePath, fileNameCurrent) = os.path.split(filename)
  (prefixCurrent, vCurrent) =  nukescripts.version_get(fileNameCurrent, "v")
  # Set maxV to the current version + 1
  maxV = int(vCurrent) + 1

  # Get the base name for the current file version.
  # i.e. the bit of the filename before the version number.
  baseNameRegex = "(.*)" + str(prefixCurrent)
  baseMatch = re.match(baseNameRegex, fileNameCurrent, re.IGNORECASE)

  if not baseMatch:
    return maxV

  baseNameCurrent = baseMatch.group(1)

  # Iterate the files in the current directory
  for fileName in os.listdir(basePath):
    # get the base name of each file.
    match = re.match(baseNameRegex, fileName, re.IGNORECASE)
    if not match:
      continue

    baseNameFile = match.group(1)

    # Check whether the base name is the same as the current file
    if baseNameFile == baseNameCurrent:
      # Compare the v number and update maxV if needed.
      (prefix, version) = nukescripts.version_get(fileName, "v")
      if int(version) > maxV:
        maxV = int(version) + 1

  return maxV



class VersionHelper(object):
  """Helper class for storing the new version information"""
  """Intended to be created per rootname."""
  def __init__(self, rootname):
    (prefix, v) =  nukescripts.version_get(rootname, "v")
    self._rootname = rootname
    self._prefix = prefix
    self._currentV = int(v)
    self._maxV = findMaxVersionForFileName(rootname)


  def hasVersion(self):
    return self._currentV is not None

  def nextVersion(self):
    return self._currentV + 1

  def maxVersion(self):
    return self._maxV

  def currentVersionString(self):
    return self._rootname

  def nextVersionString(self):
    return self.versionString(self.nextVersion())

  def maxVersionString(self):
    return self.versionString(self.maxVersion())

  def versionString(self, version):
    return nukescripts.version_set(self._rootname, self._prefix, self._currentV, version)

#End VersionHelper


class VersionConflictDialog(QtWidgets.QDialog):
  """Dialog which gives the user options for resolving version conflicts"""
  def __init__(self,versionHelper,parent=None):
    super(VersionConflictDialog, self).__init__(parent)

    self._newPath = None
    self._newVersion = None

    self._eButtonIds = {
      "overwrite": 0,
      "saveAsMax": 1,
      "saveAsVersion": 2,
    }

    self._versionHelper = versionHelper

    self.setWindowTitle("Version Conflict")
    self.setSizePolicy( QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed )
    self.setMinimumWidth(450)

    layout = QtWidgets.QVBoxLayout()
    layout.setSpacing(0)

    filename = versionHelper.nextVersionString()

    text = QtWidgets.QLabel("Unable to save script. Version:\n%s\nalready exists. \n\nWould you like to:" % filename)
    layout.addWidget(text)

    self._buttonGroup = QtWidgets.QButtonGroup(self)

    overwriteButton = QtWidgets.QRadioButton("Overwrite existing version")
    self._buttonGroup.addButton(overwriteButton)
    self._buttonGroup.setId(overwriteButton, self._eButtonIds["overwrite"])
    overwriteButton.setChecked(True)

    saveAsmaxVersionButton = QtWidgets.QRadioButton("Save as max version (%s)" % versionHelper._maxV)
    self._buttonGroup.addButton(saveAsmaxVersionButton)
    self._buttonGroup.setId(saveAsmaxVersionButton, self._eButtonIds["saveAsMax"])

    saveAsVersionButton = QtWidgets.QRadioButton("Save as version: ")
    self._buttonGroup.addButton(saveAsVersionButton)
    self._buttonGroup.setId(saveAsVersionButton, self._eButtonIds["saveAsVersion"])

    self._saveAsVersionSpin = QtWidgets.QSpinBox()
    self._saveAsVersionSpin.setValue(versionHelper._maxV)
    self._saveAsVersionSpin.setButtonSymbols(QtWidgets.QAbstractSpinBox.NoButtons)
    self._saveAsVersionSpin.setFixedWidth(30)
    self._saveAsVersionSpin.setContentsMargins(0,0,0,0)

    # Negative versions are not allowed, so set min valid version to 1
    versionValidator = QtGui.QIntValidator()
    versionValidator.setBottom(1)
    self._saveAsVersionSpin.lineEdit().setValidator(versionValidator)

    saveAsVerionLayout = QtWidgets.QHBoxLayout()
    saveAsVerionLayout.setSpacing(0)
    saveAsVerionLayout.setContentsMargins(0,0,0,0)
    saveAsVerionLayout.setAlignment(QtCore.Qt.AlignLeft)
    saveAsVerionLayout.addWidget(saveAsVersionButton)
    saveAsVerionLayout.addWidget(self._saveAsVersionSpin)

    layout.addWidget(overwriteButton)
    layout.addWidget(saveAsmaxVersionButton)
    layout.addLayout(saveAsVerionLayout)

    # Standard buttons for Add/Cancel
    buttonbox = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
    buttonbox.accepted.connect(self.accept)
    buttonbox.rejected.connect(self.reject)
    layout.addWidget(buttonbox)

    self.setLayout(layout)

  def showDialog(self):
    result = self.exec_()

    if result:
      buttonId = self._buttonGroup.checkedId()

      if(buttonId < 0 ):
        return None

      #Get the correct path for that button ID
      if buttonId is self._eButtonIds["overwrite"]:
        self._newPath = self._versionHelper.nextVersionString()
        self._newVersion = self._versionHelper.nextVersion()
      elif buttonId is self._eButtonIds["saveAsMax"]:
        self._newPath = self._versionHelper.maxVersionString()
        self._newVersion = self._versionHelper.maxVersion()
      elif buttonId is self._eButtonIds["saveAsVersion"]:
        self._newVersion  = self._saveAsVersionSpin.value()
        self._newPath = self._versionHelper.versionString(self._newVersion )

    return result

  def getNewFilePath(self):
    # Get the checked button id from the button group
    return self._newPath

  def getNewVersionNumber(self):
    return self._newVersion

#End VersionDialog


def set_fileknob_version(knob, version):
  """Sets version of the filename knob to the passed in version.
     Throws with ValueError if fileKnob has no version."""
  currentPath = knob.value()
  if currentPath:
    (prefix, v) = nukescripts.version_get(currentPath, "v")
    newPath = nukescripts.version_set(currentPath, prefix, int(v), version)
    knob.setValue(newPath)



def timeline_write_version_set(version):
  """Sets the version number in the file path of the 'timeline' write node"""
  kTimelineWriteNodeKnobName = "timeline_write_node"

  timelineWriteNodeKnob = nuke.root().knob(kTimelineWriteNodeKnobName)
  if timelineWriteNodeKnob is not None:
    timelineWriteNodeName = timelineWriteNodeKnob.getText()
    writeNode = nuke.toNode(timelineWriteNodeName)
    if writeNode is not None:
      # Set file knob
      fileKnob = writeNode['file']
      set_fileknob_version(fileKnob, version)

      # Set proxy knob
      proxyKnob = writeNode['proxy']
      set_fileknob_version(proxyKnob, version)



def script_version_up():
  """ Increments the versioning in the script name and the path of the timeline
  write nodes, then saves the new version. """
  # Set up the version helper
  root_name = nuke.toNode("root").name()

  try:
    versionHelper = VersionHelper(root_name)
  except ValueError as e:
    nuke.message("Unable to save new comp version:\n%s" % str(e))
    return

  newFileName = versionHelper.nextVersionString()
  newVersion = versionHelper.nextVersion()

  # If the next version number already exists we need to ask the user how to proceed
  newVersionExists = os.path.exists( newFileName )
  if newVersionExists:
    versionDialog = VersionConflictDialog(versionHelper)
    cancelVersionUp = not versionDialog.showDialog()
    if cancelVersionUp:
      return
    else:
      newFileName = versionDialog.getNewFilePath()
      newVersion = versionDialog.getNewVersionNumber()

  # Get the Studio write Node and version up before saving the script
  try:
    timeline_write_version_set(newVersion)
  except Exception as e:
    shouldContinue = nuke.ask("Unable to set Write node version:\n%s\nDo you want to continue saving new comp version?" % str(e))
    if not shouldContinue:
      return

  #Make the new directory if needed
  dirName = os.path.dirname( newFileName )
  if not os.path.exists( dirName ):
      os.makedirs( dirName )

  #Save the script and add to the bin
  nuke.scriptSaveAs(newFileName)
  if nuke.env['studio']:
    from hiero.ui.nuke_bridge.nukestudio import addNewScriptVersionToBin
    addNewScriptVersionToBin(root_name, newFileName)


# MAN MADE MATERIAL
def write_nodes_version_up():
    """Increments the versioning in the file paths of all write nodes"""
    for node in nuke.allNodes("Write"):
        file_knob = node["file"]
        if file_knob is not None:
            current_path = file_knob.value()
            if current_path:
                dirname, basename = os.path.split(current_path)  # Split directory and filename
                basename, ext = os.path.splitext(basename)  # Split basename and extension
                prefix, v = nukescripts.version_get(basename, "v")  # Extract version from basename
                new_basename = nukescripts.version_set(basename, prefix, int(v), int(v) + 1)  # Version up basename
                new_dirname = dirname.replace(prefix + str(v).zfill(4), prefix + str(int(v) + 1).zfill(4))  # Update directory name
                new_path = os.path.join(new_dirname, new_basename + ext)  # Reconstruct full path
                file_knob.setValue(new_path)



def script_and_write_nodes_version_up():
  # Just calls script_version_up
  # script_version_up()
  write_nodes_version_up()



def get_script_data():
  activechans = nuke.Root.channels()
  totchan = len(activechans)

  root = nuke.toNode("root")
  rez = root.knob("proxy").value()

  numnodes = len(nuke.allNodes())

  chaninuse = totchan
  chanleft = 1023-totchan
  memusage = nuke.cacheUsage()/1024/1024
  output = "Script : "+root.name()+"\n"
  output = output+"Total nodes: "+str(numnodes)+"\n"
  if rez:
    output = output+"\nResolution : --PROXY--\n"
  else:
    output = output+"\nResolution : **FULL RES**\n"
  output += "\nElements:\n"+nukescripts.get_reads("long")

  output += "\nChannels in use: "+str(totchan)+"\n"
  output += "Channels left: "+str(chanleft)+"\n"
  output += "\nCache Usage: "+str(memusage)+" mb\n"
  output += "\nChannel Data :\n"

  layers = nuke.Root.layers()
  for i in layers:
    output += "\n"+i.name()+"\n"
    channels = i.channels()
    for j in channels:
      if j in activechans:
        output += "\t"+j+"\n"

  return output



def script_data():
  nuke.display("nukescripts.get_script_data()", nuke.root())



def script_directory():
  return nuke.script_directory()



write_nodes_version_up()

# -------------------------------------------------------------------------- #

scratchpad and notes:


import nuke

def decompose_script_name(script_name):
    # Extracting filename_prefix, name_version_delimiter ("_v"),
    # version_number, and file_suffix
    filename_prefix, name_version_delimiter, remaining = \
        script_name.rpartition("_v")
    version_number, file_suffix = remaining.split(".")
   
    # Extracting shot_name and task_suffix ("_nuke_comp")
    shot_name, _, task_suffix = filename_prefix.rpartition("_nuke_comp")

    # Removing leading underscore from task_suffix to get task_type
    task_type = task_suffix.lstrip("_")

    # Constructing version_name
    version_name = f"v{version_number.zfill(4)}"

    # Constructing img_seq_ver
    img_seq_ver = f"{filename_prefix}_{version_name}.%08d{file_suffix}"

    return {
        "shot_name":       shot_name,
        "filename_prefix": filename_prefix,
        "task_type":       task_type,
        "version_name":    version_name,
        "img_seq_ver":     img_seq_ver
    }

def decompose_file_path(script_name, script_info):
    # Constructing img_seq_dir_ver
    img_seq_dir_ver = f"{script_info['filename_prefix']}_{script_info['version_name']}"

    # Splitting file path into filepath_prefix and img_seq_dir_ver and img_seq_ver
    filepath_prefix, _, remaining = script_name.rpartition(img_seq_dir_ver)

    return filepath_prefix, img_seq_dir_ver, remaining

def update_write_node_path():
    # Get the current script name
    script_name = nuke.root().name()
    
    # Decompose script name to derive variables
    script_info = decompose_script_name(script_name)
    
    # Decompose file path to derive variables
    filepath_prefix, img_seq_dir_ver, img_seq_ver = decompose_file_path(script_name, script_info)

    # Constructing updated file path for the write node
    updated_file_path = f"{filepath_prefix}{img_seq_dir_ver}/{img_seq_ver}"

    # Get the write nodes in the script
    write_nodes = [node for node in nuke.allNodes() if node.Class() == 'Write']

    # Update the paths in each write node
    for node in write_nodes:
        # Clear out the existing file path
        node['file'].setValue('')
        
        # Update the file path in the write node
        node['file'].setValue(updated_file_path)

# Add a callback to the script_save event
nuke.addOnScriptSave(update_write_node_path)











Here is the example jobStructure data:

set jobsDir "/JOBS"
    set jobName "xray_tango"
set jobDir "$jobsDir/$jobName"

set shotsDir "$jobDir/shots"
    set shotName "shot_0010"
set shotDir "$shotsDir/$shotName"
set mediaDir "$shotDir/media"
set rendersDir "$mediaDir/renders"
set sourcesDir "$mediaDir/sources"
set scriptsDir "shotDir/scripts"
    set appName "3dequalizer" - no
    set appName "aftereffects" - no
    set appName "baselight" - no
    set appName "blender" - yes
    set appName "c4d" - no
    set appName "flame" - yes
    set appName "houdini" - yes
    set appName "katana" -yes
    set appName "mari" - no
    set appName "maya" - yes
    set appName "nuke" - yes
    set appName "resolve" - no
    set appName "silhouette" - no
    set appName "syntheyes" - no
set appDir "$scriptsDir/$appName"
set appTasksDir "$appDir/tasks"
    set taskType "anim"
    set taskType "color"
    set taskType "comp"
    set taskType "fx"
    set taskType "light"
    set taskType "model"
    set taskType "paint"
    set taskType "precomp"
    set taskType "roto"
    set taskType "texture"
set appTaskDir "$appTasksDir/$taskType"
    set versionName "v0000"

$jobName changes per job
$shotName changes for every shot for every job
$versionName changes for every version for every shot for every job

Nuke scripts get saved in the appropriate directory:
e.g "/JOBS/xray_tango/shots/shot_0010/scripts/nuke/comp/shot_0010_nuke_comp_v0000.nk"
scriptPath can be shortened to "($appTasksDir/$taskType)"
scriptName is "$shotName_$appName_$taskType_$versionName.nk"


This script will contain a Write node.
The path for file in this Write node is:
e.g. "$rendersDir/$shotName_$appName_$taskType_$versionName/$shotName_$appName_$taskType_$versionName.%08d.exr"

I require a TCL script to analyze the versionName of the scriptName and update the versionName instances in the file path of the Write node


# Get the current script name
set scriptName [file rootname [value root.name]]

# Get the directory containing the current script
set scriptDir [file dirname [value root.name]]

# Extract components from the script name
lassign [split $scriptName "_"] shotName appName taskType versionName

# Find the position of the "scripts" directory in the path
set scriptsIndex [lsearch -glob -inline $scriptDir "*scripts*"]

# Extract the project root directory up to the "scripts" directory
set projectRoot [lrange $scriptDir 0 [expr {$scriptsIndex - 1}]]

# Define the renders directory
set rendersDir "$projectRoot/media/renders/"

# Construct the file name prefix
set fileNamePrefix "${shotName}_${appName}_${taskType}_${versionName}"

# Construct the updated file path
set updatedFilePath "${rendersDir}${fileNamePrefix}/${fileNamePrefix}.%08d.exr"

# Get the Write node
set writeNode [value Write1]

# Set the updated file path for the Write node
$writeNode file $updatedFilePath

The python script:

import nuke
import os
import logging

# Configure logging
logging.basicConfig(level=logging.DEBUG)

# Get the current script name
script_name = os.path.splitext(nuke.root().name())[0]
logging.debug(f"Script Name: {script_name}")

# Get the directory containing the current script
script_dir = os.path.dirname(nuke.root().name())
logging.debug(f"Script Directory: {script_dir}")

# Extract components from the script name
components = script_name.split("_")
if len(components) == 5:
    shot_prefix, shot_number, app_name, task_name, version_name = components
    logging.debug(f"Shot Prefix: {shot_prefix}, Shot Number: {shot_number}, App Name: {app_name}, Task Name: {task_name}, Version Name: {version_name}")
else:
    logging.error("Invalid script name format. Expected five components separated by underscores.")

# Find the position of the "scripts" directory in the path
scripts_index = script_dir.find("scripts")
logging.debug(f"Scripts Index: {scripts_index}")

# Extract the project root directory up to the "scripts" directory
project_root = script_dir[:scripts_index]
logging.debug(f"Project Root Directory: {project_root}")

# Define the renders directory
renders_dir = os.path.join(project_root, "media", "renders")
logging.debug(f"Renders Directory: {renders_dir}")

# Construct the file name prefix
file_name_prefix = f"{shot_prefix}_{shot_number}_{app_name}_{task_name}_{version_name}"
logging.debug(f"File Name Prefix: {file_name_prefix}")

# Construct the updated file path
updated_file_path = os.path.join(renders_dir, file_name_prefix, f"{file_name_prefix}.%08d.exr")
logging.debug(f"Updated File Path: {updated_file_path}")

# Get the Write node
write_node = nuke.toNode("Write1")

# Set the updated file path for the Write node
write_node["file"].setValue(updated_file_path)
logging.debug("Updated file path for Write node")







import os.path
import nuke
import nukescripts
import re
try:
    from PySide6 import QtWidgets, QtCore, QtGui
except ImportError:
    from PySide2 import QtWidgets, QtCore, QtGui

kCommandField = 'Command:'
last_cmd = ''


def write_nodes_version_up():
    """Increments the versioning in the file paths of all write nodes"""
    for node in nuke.allNodes("Write"):
        file_knob = node["file"]
        if file_knob is not None:
            current_path = file_knob.value()
            if current_path:
                dirname, basename = os.path.split(current_path)  # Split directory and filename
                basename, ext = os.path.splitext(basename)  # Split basename and extension
                prefix, v = nukescripts.version_get(basename, "v")  # Extract version from basename
                new_basename = nukescripts.version_set(basename, prefix, int(v), int(v) + 1)  # Version up basename
                new_dirname = dirname.replace(prefix + str(v).zfill(4), prefix + str(int(v) + 1).zfill(4))  # Update directory name
                new_path = os.path.join(new_dirname, new_basename + ext)  # Reconstruct full path
                file_knob.setValue(new_path)


write_nodes_version_up()


# filename: menu.py

# Installation:
# Windows: C:\Users\YourUsername\.nuke\menu.py
# macOS: /Users/YourUsername/.nuke/menu.py
# Linux: /home/YourUsername/.nuke/menu.py

import os.path
import nuke
import nukescripts
import re
try:
    from PySide6 import QtWidgets, QtCore, QtGui
except ImportError:
    from PySide2 import QtWidgets, QtCore, QtGui

# Function to update the versioning in the file paths of all write nodes
def update_write_node_version():
    
    """Increments the versioning in the file paths of all write nodes"""
    root_name = nuke.toNode("root").name()

    # Get the version number from the script name
    (script_prefix, script_version) = nukescripts.version_get(root_name, "v")

    for node in nuke.allNodes("Write"):
        
        file_knob = node["file"]

        if file_knob is not None:
            
            current_path = file_knob.value()

            if current_path:
                
                # Split directory and filename
                dirname, basename = os.path.split(current_path)

                # Split basename and extension
                basename, ext = os.path.splitext(basename)

                # Extract version from basename
                (path_prefix, path_version) = nukescripts.version_get(basename, "v")

                # Check if script version is greater than file path version
                if script_version > path_version:
                    
                    # Version up basename
                    new_basename = nukescripts.version_set(
                        basename, path_prefix, int(path_version), int(script_version)
                    )
                    # Update directory name
                    new_dirname = dirname.replace(
                        path_prefix + str(path_version).zfill(4), path_prefix + str(int(script_version)).zfill(4)
                    )
                    # Reconstruct full path
                    new_path = os.path.join(new_dirname, new_basename + ext)
                    file_knob.setValue(new_path)


# Add a callback to the script_save event
nuke.addOnScriptSave(update_write_node_version)



















# format "3424 2202 0 0 3424 2202 1 "

<clip>
    <handler>
        <name>shot_0010_nuke_comp</name>
        <options>
            <ScanPattern type="string">/JOBS/xray_tango/shots/{name}/media/renders/{shotName}_nuke_comp_v{version}/{shotName}_nuke_comp_v{version}.{frame}.exr</ScanPattern>
        </options>
    </handler>
</clip>

/JOBS/my_special_job/shots/{name}/media/renders/{shotName}_nuke_comp_v{version}/{shotName}_nuke_comp_v{version}.{frame}.exr

<?xml version="1.0" encoding="UTF-8"?>
<clip type="clip" version="5">
	<name>shot_0010_nuke_comp</name>
	<handler>
		<name>MIO Clip</name>
		<options>
			<ScanPattern type="string">/JOBS/xray_tango/shots/{shotName}/media/renders/{shotName}_nuke_comp_v{version}/{shotName}_nuke_comp_v{version}.{frame}.exr</ScanPattern>
		</options>
	</handler>
</clip>






# # Get the project nickname
the_current_nickname = "xray_tango"

# Define paths
jobs_root = '/JOBS'
job_dir = os.path.join(jobs_root, the_current_nickname)
shots_dir = os.path.join(job_dir, 'shots')

# List shot directories
shots_list = os.listdir(shots_dir)

# Count the number of shots
shots_count = len(shots_list)

# Dictionary to store 'renders' and 'sources' directories for each shot
shot_directories = {}

# Iterate over shot directories
for shot_name in shots_list:

    # Define paths for 'renders' and 'sources' directories
    # openclips_dir = os.path.join(shots_dir, shot_name, 'openclip')
    # scripts_dir = os.path.join(shots_dir, shot_name, 'scripts')
    renders_dir = os.path.join(shots_dir, shot_name, 'media', 'renders')
    sources_dir = os.path.join(shots_dir, shot_name, 'media', 'sources')
    
    # Store paths in the dictionary
    shot_directories[shot_name] = {
        # 'openclips': openclips_dir,
        # 'scripts': scripts_dir,
        'renders': renders_dir,
        'sources': sources_dir
    }

# Define Application Names and Tasks directories
app_name = "nuke"

task_type_array = (
    "anim", "color", "comp", "fx", "light",
    "model", "paint", "precomp", "roto", "texture"
)

# Create openclip file
with open(shot_task_openclip_path, 'w') as shot_task_openclip_file:
    # Write openclip content
    shot_task_openclip_file.write(f"""Root {{
<?xml version="1.0" encoding="UTF-8"?>
<clip type="clip" version="5">
	<name>shot_0010_nuke_comp</name>
	<handler>
		<name>MIO Clip</name>
		<options>
			<ScanPattern type="string">{renders_dir}/{shot_task_name}/{shot_task_name}</ScanPattern>
		</options>
	</handler>
</clip>
}}""")


<?xml version="1.0" encoding="UTF-8"?>
<clip type="clip" version="5">
        <name>shot_0010_nuke_comp</name>
        <handler>
                <name>MIO Clip</name>
                <options>
                        <ScanPattern type="string">/JOBS/xray_tango/shots/{shotName}/media/renders/{shotName}_nuke_comp_v{version}/{shotName}_nuke_comp_v{version}.{frame}.exr</Sca>
                </options>
        </handler>
</clip>



{shots_dir}/{shotName}/media/renders/{{shotName}}_{app_name}_{task_type}_v{{version}}/{{shotName}}_{app_name}_{task_type}_v{{version}}.{{frame}}.exr

[PYTHON HOOK] Duplicate module name found logik_projekt_dated_objects 
(
   /opt/Autodesk/shared/python/logik_projekt/projekt_tools/logik_projekt_dated_objects/logik_projekt_dated_objects_v1.0/logik_projekt_dated_objects.py 
   vs 
   /opt/Autodesk/shared/python/setups/shared/python/logik_projekt/projekt_tools/logik_projekt_dated_objects/logik_projekt_dated_objects_v1.0/logik_projekt_dated_objects.py). Python does not allow more than one module with a given name to be loaded at the same time. /opt/Autodesk/shared/python/setups/shared/python/logik_projekt/projekt_tools/logik_projekt_dated_objects/logik_projekt_dated_objects_v1.0/logik_projekt_dated_objects.py will be used.
[PYTHON HOOK] Duplicate module name found logik_projekt_layout (/opt/Autodesk/shared/python/logik_projekt/projekt_tools/logik_projekt_layout/logik_projekt_layout_v1.0/logik_projekt_layout.py vs /opt/Autodesk/shared/python/setups/shared/python/logik_projekt/projekt_tools/logik_projekt_layout/logik_projekt_layout_v1.0/logik_projekt_layout.py). Python does not allow more than one module with a given name to be loaded at the same time. /opt/Autodesk/shared/python/setups/shared/python/logik_projekt/projekt_tools/logik_projekt_layout/logik_projekt_layout_v1.0/logik_projekt_layout.py will be used.
[PYTHON HOOK] Duplicate module name found mmm_comp (/opt/Autodesk/shared/python/man_made_material/openclip_workflow/mmm_comp/mmm_comp_v1.1/mmm_comp.py vs /opt/Autodesk/shared/python/setups/shared/python/man_made_material/openclip_workflow/mmm_comp/mmm_comp_v1.1/mmm_comp.py). Python does not allow more than one module with a given name to be loaded at the same time. /opt/Autodesk/shared/python/setups/shared/python/man_made_material/openclip_workflow/mmm_comp/mmm_comp_v1.1/mmm_comp.py will be used.
[PYTHON HOOK] Duplicate module name found pyflame_lib_mmm_comp (/opt/Autodesk/shared/python/man_made_material/openclip_workflow/mmm_comp/mmm_comp_v1.1/pyflame_lib_mmm_comp.py vs /opt/Autodesk/shared/python/setups/shared/python/man_made_material/openclip_workflow/mmm_comp/mmm_comp_v1.1/pyflame_lib_mmm_comp.py). Python does not allow more than one module with a given name to be loaded at the same time. /opt/Autodesk/shared/python/setups/shared/python/man_made_material/openclip_workflow/mmm_comp/mmm_comp_v1.1/pyflame_lib_mmm_comp.py will be used.
[PYTHON HOOK] Duplicate module name found mmm_mattes (/opt/Autodesk/shared/python/man_made_material/openclip_workflow/mmm_mattes/mmm_mattes_v1.1/mmm_mattes.py vs /opt/Autodesk/shared/python/setups/shared/python/man_made_material/openclip_workflow/mmm_mattes/mmm_mattes_v1.1/mmm_mattes.py). Python does not allow more than one module with a given name to be loaded at the same time. /opt/Autodesk/shared/python/setups/shared/python/man_made_material/openclip_workflow/mmm_mattes/mmm_mattes_v1.1/mmm_mattes.py will be used.
[PYTHON HOOK] Duplicate module name found pyflame_lib_mmm_mattes (/opt/Autodesk/shared/python/man_made_material/openclip_workflow/mmm_mattes/mmm_mattes_v1.1/pyflame_lib_mmm_mattes.py vs /opt/Autodesk/shared/python/setups/shared/python/man_made_material/openclip_workflow/mmm_mattes/mmm_mattes_v1.1/pyflame_lib_mmm_mattes.py). Python does not allow more than one module with a given name to be loaded at the same time. /opt/Autodesk/shared/python/setups/shared/python/man_made_material/openclip_workflow/mmm_mattes/mmm_mattes_v1.1/pyflame_lib_mmm_mattes.py will be used.
[PYTHON HOOK] Duplicate module name found mmm_neat_video (/opt/Autodesk/shared/python/man_made_material/openclip_workflow/mmm_neat_video/mmm_neat_video_v1.1/mmm_neat_video.py vs /opt/Autodesk/shared/python/setups/shared/python/man_made_material/openclip_workflow/mmm_neat_video/mmm_neat_video_v1.1/mmm_neat_video.py). Python does not allow more than one module with a given name to be loaded at the same time. /opt/Autodesk/shared/python/setups/shared/python/man_made_material/openclip_workflow/mmm_neat_video/mmm_neat_video_v1.1/mmm_neat_video.py will be used.
[PYTHON HOOK] Duplicate module name found pyflame_lib_mmm_neat_video (/opt/Autodesk/shared/python/man_made_material/openclip_workflow/mmm_neat_video/mmm_neat_video_v1.1/pyflame_lib_mmm_neat_video.py vs /opt/Autodesk/shared/python/setups/shared/python/man_made_material/openclip_workflow/mmm_neat_video/mmm_neat_video_v1.1/pyflame_lib_mmm_neat_video.py). Python does not allow more than one module with a given name to be loaded at the same time. /opt/Autodesk/shared/python/setups/shared/python/man_made_material/openclip_workflow/mmm_neat_video/mmm_neat_video_v1.1/pyflame_lib_mmm_neat_video.py will be used.
[PYTHON HOOK] Duplicate module name found mmm_precomp (/opt/Autodesk/shared/python/man_made_material/openclip_workflow/mmm_precomp/mmm_precomp_v1.1/mmm_precomp.py vs /opt/Autodesk/shared/python/setups/shared/python/man_made_material/openclip_workflow/mmm_precomp/mmm_precomp_v1.1/mmm_precomp.py). Python does not allow more than one module with a given name to be loaded at the same time. /opt/Autodesk/shared/python/setups/shared/python/man_made_material/openclip_workflow/mmm_precomp/mmm_precomp_v1.1/mmm_precomp.py will be used.
[PYTHON HOOK] Duplicate module name found pyflame_lib_mmm_precomp (/opt/Autodesk/shared/python/man_made_material/openclip_workflow/mmm_precomp/mmm_precomp_v1.1/pyflame_lib_mmm_precomp.py vs /opt/Autodesk/shared/python/setups/shared/python/man_made_material/openclip_workflow/mmm_precomp/mmm_precomp_v1.1/pyflame_lib_mmm_precomp.py). Python does not allow more than one module with a given name to be loaded at the same time. /opt/Autodesk/shared/python/setups/shared/python/man_made_material/openclip_workflow/mmm_precomp/mmm_precomp_v1.1/pyflame_lib_mmm_precomp.py will be used.


|----------------|-------|--------|
|  APPLICATION   | ASCII | PYTHON |
|      NAME      | SETUP |  API   |
|----------------|-------|--------|
| "3dequalizer"  |   -   |  NO    |
| "aftereffects" |   -   |  NO    |
| "baselight"    |   -   |  NO    |
| "blender"      |   -   |  YES   |
| "c4d"          |   -   |  NO    |
| "flame"        |   -   |  YES   |
| "houdini"      |   -   |  YES   |
| "katana"       |   -   |  YES   |
| "mari"         |   -   |  NO    |
| "maya"         |   -   |  YES   |
| "nuke"         |   -   |  YES   |
| "resolve"      |   -   |  NO    |
| "silhouette"   |   -   |  NO    |
| "syntheyes"    |   -   |  NO    |
|----------------|-------|--------|